package words

import (
	"math/big"
	"strings"

	"github.com/pkg/errors"

	"github.com/tendermint/go-crypto/keys/words/wordlist"
)

const BankSize = 2048

type Codec interface {
	BytesToWords([]byte) ([]string, error)
	WordsToBytes([]string) ([]byte, error)
}

type WordCodec struct {
	words	[]string
	bytes	map[string]int
	check	ECC
}

var _ Codec = &WordCodec{}

func NewCodec(words []string) (codec *WordCodec, err error) {
	if len(words) != BankSize {
		return codec, errors.Errorf("Bank must have %d words, found %d", BankSize, len(words))
	}

	res := &WordCodec{
		words:	words,

		check:	NewIEEECRC32(),
	}

	return res, nil
}

func LoadCodec(bank string) (codec *WordCodec, err error) {
	words, err := loadBank(bank)
	if err != nil {
		return codec, err
	}
	return NewCodec(words)
}

func MustLoadCodec(bank string) *WordCodec {
	codec, err := LoadCodec(bank)
	if err != nil {
		panic(err)
	}
	return codec
}

func loadBank(bank string) ([]string, error) {
	filename := "keys/words/wordlist/" + bank + ".txt"
	words, err := wordlist.Asset(filename)
	if err != nil {
		return nil, err
	}
	wordsAll := strings.Split(strings.TrimSpace(string(words)), "\n")
	return wordsAll, nil
}

func wordlenFromBytes(numBytes int) int {

	return (8*numBytes + 10) / 11
}

func bytelenFromWords(numWords int) (length int, maybeShorter bool) {

	length = 11 * numWords / 8

	if wordlenFromBytes(length-1) == numWords {
		maybeShorter = true
	}
	return
}

func (c *WordCodec) BytesToWords(raw []byte) (words []string, err error) {

	data := c.check.AddECC(raw)
	numWords := wordlenFromBytes(len(data))

	n2048 := big.NewInt(2048)
	nData := big.NewInt(0).SetBytes(data)
	nRem := big.NewInt(0)

	for i := 0; i < numWords; i++ {
		nData.DivMod(nData, n2048, nRem)
		rem := nRem.Int64()
		w := c.words[rem]

		_, err := c.GetIndex(w)
		if err != nil {
			return nil, err
		}
		words = append(words, w)
	}
	return words, nil
}

func (c *WordCodec) WordsToBytes(words []string) ([]byte, error) {
	l := len(words)

	if l == 0 {
		return nil, errors.New("Didn't provide any words")
	}

	n2048 := big.NewInt(2048)
	nData := big.NewInt(0)

	for i := 1; i <= l; i++ {
		rem, err := c.GetIndex(words[l-i])
		if err != nil {
			return nil, err
		}
		nRem := big.NewInt(int64(rem))
		nData.Mul(nData, n2048)
		nData.Add(nData, nRem)
	}

	dataBytes := nData.Bytes()

	outLen, flex := bytelenFromWords(len(words))
	toCheck := make([]byte, outLen)
	if len(dataBytes) > outLen {
		return nil, errors.New("Invalid data, could not have been generated by this codec")
	}
	copy(toCheck[outLen-len(dataBytes):], dataBytes)

	output, err := c.check.CheckECC(toCheck)
	if flex && err != nil {

		toCheck = toCheck[1:]
		output, err = c.check.CheckECC(toCheck)
	}

	return output, err
}

func (c *WordCodec) GetIndex(word string) (int, error) {

	if c.bytes == nil {
		b := map[string]int{}
		for i, w := range c.words {
			if _, ok := b[w]; ok {
				return -1, errors.Errorf("Duplicate word in list: %s", w)
			}
			b[w] = i
		}
		c.bytes = b
	}

	rem, ok := c.bytes[word]
	if !ok {
		return -1, errors.Errorf("Unrecognized word: %s", word)
	}
	return rem, nil
}
